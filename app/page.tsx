"use client";

import { useEffect, useMemo, useState } from "react";
import { PipelineConfigurator } from "@/components/pipeline-configurator";
import { RunLog, StatusFeed } from "@/components/status-feed";
import { PipelineRunRequest, pipelineRequestSchema } from "@/lib/schema";
import styles from "./page.module.css";

export default function HomePage() {
  const [tokenPayload, setTokenPayload] = useState<PipelineRunRequest>({
    openaiKey: "",
    elevenLabsKey: "",
    pexelsKey: "",
    youtubeClientId: "",
    youtubeClientSecret: "",
    youtubeRefreshToken: "",
    voiceId: "21m00Tcm4TlvDq8ikWAM",
    videoTopic: "daily AI news round-up",
    targetDurationSeconds: 120,
    uploadTitleTemplate: "Daily AI Highlights - {{date}}",
    uploadDescriptionTemplate:
      "Automated AI news for {{date}}. Chapters:{{chapters}}\n\nGenerated by Agentic Automation.",
    uploadTags: ["AI", "news", "automation", "daily roundup"],
    visibility: "unlisted",
    allowCopyrightAudio: false,
    preset: "news",
    webhookUrl: "",
    runContext: "",
    extraInstructions: ""
  });

  const [runLog, setRunLog] = useState<RunLog[]>([]);
  const [isRunning, setIsRunning] = useState(false);

  useEffect(() => {
    try {
      const cached = window.localStorage.getItem("agentic-pipeline-config");
      if (cached) {
        const parsed = pipelineRequestSchema.parse(JSON.parse(cached));
        setTokenPayload(parsed);
      }
    } catch {
      // ignore parse errors and fall back to defaults
    }
  }, []);

  useEffect(() => {
    window.localStorage.setItem(
      "agentic-pipeline-config",
      JSON.stringify(tokenPayload)
    );
  }, [tokenPayload]);

  const sortedTags = useMemo(
    () => tokenPayload.uploadTags.filter(Boolean),
    [tokenPayload.uploadTags]
  );

  const handleRun = async (payload: PipelineRunRequest) => {
    setIsRunning(true);
    setRunLog([]);
    try {
      const response = await fetch("/api/run", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        const err = await response.json().catch(() => ({}));
        throw new Error(err?.message ?? "Pipeline failed to start");
      }

      const stream = response.body;
      if (!stream) {
        throw new Error("No response stream from pipeline");
      }

      const reader = stream.getReader();
      const decoder = new TextDecoder();
      let buffer = "";

      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        buffer += decoder.decode(value, { stream: true });
        const segments = buffer.split("\n\n");
        while (segments.length > 1) {
          const segment = segments.shift();
          if (!segment) continue;
          if (!segment.startsWith("data:")) continue;
          const payload = segment.replace("data:", "").trim();
          if (!payload || payload === "[DONE]") continue;
          try {
            const parsed = JSON.parse(payload) as RunLog;
            setRunLog((prev) => [...prev, parsed]);
          } catch (error) {
            console.error("Failed to parse SSE segment", error);
          }
        }
        buffer = segments[0] ?? "";
      }
    } catch (error) {
      console.error(error);
      setRunLog((prev) => [
        ...prev,
        {
          id: crypto.randomUUID(),
          status: "error",
          title: "Pipeline Failure",
          detail:
            error instanceof Error ? error.message : "Unknown pipeline failure",
          timestamp: new Date().toISOString()
        }
      ]);
    } finally {
      setIsRunning(false);
    }
  };

  return (
    <main className={styles.main}>
      <section className={`${styles.card} glass`}>
        <PipelineConfigurator
          value={tokenPayload}
          onChange={setTokenPayload}
          onRun={handleRun}
          running={isRunning}
        />
      </section>
      <section className={`${styles.card} glass`}>
        <StatusFeed logs={runLog} active={isRunning} />
      </section>
      <section className={`${styles.metaCard} glass`}>
        <h2>Automation Presets</h2>
        <p>
          Use presets to tailor your run quickly. You can override any field
          after selecting a preset.
        </p>
        <div className={styles.presets}>
          {presetDescriptions.map((preset) => (
            <article key={preset.id}>
              <h3>{preset.title}</h3>
              <p>{preset.description}</p>
              <ul>
                {preset.highlights.map((item) => (
                  <li key={item}>{item}</li>
                ))}
              </ul>
            </article>
          ))}
        </div>
      </section>
      <section className={`${styles.metaCard} glass`}>
        <h2>Environment Variables</h2>
        <p>
          For unattended runs (including the provided cron job), set these env
          vars in Vercel:
        </p>
        <ul className={styles.envList}>
          {envVars.map((name) => (
            <li key={name}>
              <code>{name}</code>
            </li>
          ))}
        </ul>
      </section>
    </main>
  );
}

const envVars = [
  "OPENAI_API_KEY",
  "ELEVENLABS_API_KEY",
  "PEXELS_API_KEY",
  "YOUTUBE_CLIENT_ID",
  "YOUTUBE_CLIENT_SECRET",
  "YOUTUBE_REFRESH_TOKEN",
  "PIPELINE_DEFAULT_TOPIC",
  "PIPELINE_EXTRA_INSTRUCTIONS",
  "PIPELINE_UPLOAD_VISIBILITY",
  "PIPELINE_UPLOAD_TITLE_TEMPLATE",
  "PIPELINE_UPLOAD_DESCRIPTION_TEMPLATE",
  "PIPELINE_UPLOAD_TAGS",
  "PIPELINE_VOICE_ID",
  "PIPELINE_WEBHOOK_URL"
];

const presetDescriptions = [
  {
    id: "news",
    title: "AI News Pulse",
    description:
      "Built for talking-head style daily news updates using stock footage and swift B-roll.",
    highlights: [
      "2 minute duration target",
      "news ticker style summary",
      "stock montages from Pexels"
    ]
  },
  {
    id: "facts",
    title: "Daily Tech Facts",
    description:
      "Quick listicle videos with upbeat pacing, ideal for Shorts and Reels.",
    highlights: [
      "vertical clips",
      "energetic voiceover style",
      "calls to action baked in"
    ]
  },
  {
    id: "longform",
    title: "Deep Dive Stories",
    description:
      "Longer narratives with chaptered descriptions and cinematic prompts.",
    highlights: [
      "5-8 minute pacing",
      "chapter markers for description",
      "cinematic b-roll queries"
    ]
  }
];
